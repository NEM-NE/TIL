# SQL 첫걸음

## 복수의 열을 지정해 정렬하기

```sql
SELECT 열 FROM 테이블
ORDER BY 정렬할 열1 [DESC], 정렬할 열2 [DESC]
```

⇒ 열1을 기준으로 정렬 후 값이 동일하다면 열2 기준으로 정렬한다.

ORDER BY 로 정렬을 하지 않은 경우 (`SELECT * FROM TABLE`) 순서가 항상 일정하지 않다.

⇒ **데이터 베이스의 당시 상황에 따라 어떤 순서로 행을 반환할지 결정된다.**

정렬 방법을 생략하면 기본적으로 `ASC`가 되지만 데이터베이스 제품에 따라 기본값을 변경할 수 있으므로 주의해야한다.

만약 NULL 값이 내부에 있는 경우(**NULL은 특성상 대소비교를 할 수 없어 정렬 시에는 별도의 방법으로 취급**)

따라서 ORDER BY에서 NULL 값은 가장 먼저 표시되거나 가장 나중에 표시된다. (표준으로 정해지지 않아 데이터베이스 제품마다 다르다. / MySQL 같은 경우 가장 작은 값으로 취급)

## 결과 행 제한하기 - LIMIT

```sql
SELECT 열 FROM 테이블
LIMIT 행 개수 [OFFSET 시작행]
```

⇒ 전체 결과 값 중 일부만 보고 싶을 때 사용 / 표준이 아니고 MySQL, PostgreSQL에서 사용할 수 있는 문법

LIMIT 명령어는 쿼리문 맨 마지막에 사용

LIMIT는 반환할 행 수를 제한하는 기능으로 최종적인 결과값에서 뽑아서 가져온다. ⇒ 성능이 별로 안좋음

LIMIT는 표준이 아니므로 다른 데이터베이스에서는 TOP, ROWNUM를 사용한다.

Pagination 기능을 위해 OFFSET으로 시작행을 지정하여 일부만을 가져오게 할 수도 있다.

OFFSET의 기본 값은 0으로 1번째 행을 의미한다.

## 수치 연산

### NULL 값의 연산

NULL + 1은 NULL이다. ⇒ SQL에서 NULL은 0으로 처리되지 않기 때문이다.

- NULL + 1
- 1 + NULL
- 1 + 2 \* NULL
- 1 / NULL

위 연산 값은 다 NULL이다.

### 함수 연산

`함수명(인수1, 인수2, ..)`를 통해서 사용할 수 있다.

MySQL에서는 다음과 같은 연산 함수가 있다.

- FLOOR() ⇒ 버림
- MOD() ⇒ 나머지
- ABC() ⇒ 절대값
- SIGN() ⇒ 양수, 음수 부호 리턴
- CEIL() ⇒ N보다 작지 않은 정수의 최대값 리턴
- ROUND() ⇒ 반올림 함수

## 문자열 연산

문자열 결합

```sql
'ABC' || '1234' -> 'ABC1234' // Oracle, DB2, PostgreSQL
CONCAT('ABC', '1234') -> 'ABC1234' // MySQL
```

substring

```sql
SUBSTRING('ABCDE', 1, 2) -> 2번째 자리부터 1자리 추출
```

trim

```sql
TRIM('ABCDE     ') -> 공백 제거
```

CHARACTER_LENGTH ⇒ 문자열의 길이를 계산하는 함수

## 날짜 연산

```sql
SELECT CURRENT_TIMESTAMP; // CURRENT_TIMESTAMP ⇒ 함수이지만 인수를 지정할 필요가 없다.
TO_DATE('2014/01/25', 'YYYY/MM/DD') // 문자열 데이터를 원하는 서식으로 변경
SELECT CURRENT_DATE + INTERVAL 1 DAY; //  + INTERVAL 1 DAY -> 하루를 더한다.
DATEDIFF('2014/01/25', '2014/01/25')  // MySQL 날짜 차이
```

## CASE 문으로 데이터 변환하기

```sql
CASE WHEN 조건식1 THEN 식1  // WHEN NULL은 사용할 수 없다. = NULL 은 연산할 수 없기 때문에
	[WHEN 조건식2 THEN 식2]
	[ELSE 식3] // ELSE를 생략하면 ELSE NULL이 된다. 따라서 지정하는 편이 낫다
END

SELECT CASE WHEN a is null THEN 0 ELSE a END FROM TABLE; // null인 경우 0으로 바꾸기
COALESCE(a, 0) // 위 쿼리문과 똑같은 역할 a 가 null이면 0으로 변환한다.
```

### 물리삭제와 논리삭제

데이터를 삭제하는 방법은 용도에 따라 물리삭제와 논리삭제로 나뉨.

물리삭제 ⇒ SQL의 DELETE 명령을 사용해 직접 데이터를 삭제하자는 사고 방식

- 삭제되기 이전 상태로 되돌리기 어렵다

논리삭제 ⇒ 실제로 삭제하는 대신 UPDATE를 통해 삭제된 것 처럼 보이게 하는 방식 (삭제 플래그 열을 만들어 삭제되었다고 표시만 한다)

- 삭제해도 데이터베이스의 저장공간이 늘어나지 않음
- 데이터베이스 크기가 증가함에 따라 검색속도 저하
- 애플리케이션에서도 UPDATE를 하기 때문에 혼란발생

물리삭제와 논리삭제는 상황에 맞게 선택한다.

## 상관 서브쿼리

```sql
~~~WHERE EXISTS(SELECT * FROM table) // 행이 존재하면 참 아니면 거짓
SELECT * FROM table WHERE 값 IN (SELECT * FROM table) // 집합 안에 값이 있는지 확인
```

# 2주차

### 데이터베이스 객체

테이블이나 뷰, 인덱스, 프로시저 등 데이터베이스 내에서 실체하는 모든 것을 의미 (객체지향의 객체와는 다른 의미)

객체의 특징 ⇒ 이름이 존재한다. (DBMS마다 지정된 명명 규칙을 지켜야한다.)

스키마 ⇒ 데이터베이스 객체를 담는 그릇 / 서로 다른 무언가를 구분할 수 있는 네임스페이스 역할을 한다.

### 테이블 작성, 삭제, 변경

```sql
CREATE TABLE 테이블명 (컬럼명, 컬럼 타입, 컬럼 옵션)
DROP TABLE 테이블명
ALTER TABLE 테이블명 하부 명령
```

테이블의 내부 행만을 삭제할 때는 DELETE 이용 ⇒ 행이 많다면 여러가지 처리 작업에 의해서 시간이 많이 소요될 수 있다. ⇒ `TRUNCATE TABLE 테이블명` 사용

```sql
ALTER TABLE 테이블명 ADD 열 정의 -- 열 추가
ALTER TABLE 테이블명 MODIFY 열 정의 -- 열 속성 변경
ALTER TABLE 테이블명 CHANGE 기존 열이름 신규 열정의 -- 열 이름 변경
ALTER TABLE 테이블명 DROP 열 명 -- 열 삭제
```

### 제약

테이블에 들어갈 데이터를 제약하는 것을 의미

```sql
테이블 작성시 제약

CREATE TABLE 테스트 (
	id INTEGER NOT NULL,
	name VARCHAR UNIQUE -- 열에 제약을 건다.
)

CREATE TABLE 테스트 (
	id INTEGER NOT NULL,
	name VARCHAR UNIQUE -- 열에 제약을 건다.
	CONSTRAINT pk PRIMARY KEY(id) -- 테이블에 제약을 건다. CONSTRAINT 변수이름 지정
)

제약 추가

열 제약 추가 & 제약 삭제
ALTER TABLE 테이블명 MODIFY 열 정의

테이블 제약 추가
ALTER TABLE 테이블명 ADD CONSTRAINT 변수명 테이블 제약 정의

테이블 제약 삭제
ALTER TABLE 테이블명 DROP CONSTRAINT 변수명 테이블 제약 정의
```

기본키 제약 ⇒ 유니크해야 한다.

### 인덱스 구조

테이블 내에 빠르게 검색을 하고 싶다면 인덱스를 활용해야한다.

인덱스 ⇒ 색인이라는 의미처럼 키워드에 대응하는 검색 값을 빠르게 찾게 도와준다.

인덱스의 자료구조는 주로 B+Tree가 사용된다.

B+Tree ⇒ 부모 노드들의 사이값들을 자식노드로 만들되 참조값 만을 저장하고 리프노드에는 연결리스트에 실제 값을 저장하는 형태

```sql
인덱스 생성

CREATE INDEX 인덱스명 ON 테이블(컬럼명)
DROP INDEX 인덱스명

```

EXPLAIN ⇒ 쿼리를 측정해주는 명령어 ⇒ 인덱스가 제대로 동작하는지, 해당 쿼리문이 어떻게 처리되는지, 얼마나 빨리 처리되는지 등을 확인할 수 있다. ⇒ 실행 계획을 세울 수 있다.

### 뷰 작성과 삭제

뷰 ⇒ 특정 SELECT 문의 결과를 저장해놓은 것

결과 값을 저장하는 것이 아니라 쿼리를 저장하기 때문에 뷰가 자치하는 크기는 작지만 뷰를 사용할 때마다 내장된 SELECT문을 호출하기 때문에 CPU에 많은 부담이 발생한다.

```sql
뷰 생성

CREATE VIEW 뷰네임(컬럼명, 컬럼명, ..) AS SELECT ~~~
DROP VIEW 뷰네임
```

이를 개선한게 materialized view이다.

이것은 SELECT 문을 저장하는 것이 아니라 처음 만들 당시 SELECT문의 결과 값을 저장한다.

그래서 해당 테이블이 바뀔 때마다 업데이트를 해줘야하는데 이는 RDBMS가 자동으로 해준다.

그나마 뷰의 문제점을 해결할 수 있는 대안

# 3주차

## 복수의 테이블 다루기

SQL & 집합 ⇒ 관계형 데이터베이스는 집합론에 기반하여 만들어진 모델 / 집합의 관점으로 생각해라!

### 집합 연산

UNION

```sql
SELECT * FROM tableA
UNION
SELECT * FROM tableB
```

⇒ 집합에서 A U B 와 같은 역할을 한다.

⇒ 열 구성(이름)이 모두 같아야한다.

⇒ 중복된 요소는 1개만 보여준다. / 중복된 요소를 다 보고 싶다면 `UNION ALL` 사용

⇒ UNION 명령어를 연속해서 사용할 수 있다.

⇒ `ORDER BY`는 마지막 SELECT 문에만 설정 가능

MySQL 말고 다른 SQL에서는 `INTERSECT`, `EXPECT`가 존재한다.

### 테이블 결합

곱집합 ⇒ 모든 경우의 수를 계산

Ex) A = {1, 2, 3} B = {a, b, c} A \* B = {a1, a2, a3, b1, b2, b3, c1, c2, c3}

SQL에서 곱집합은 `Cross Join`

```sql
SELECT * FROM tableA, tableB
```

UNION과 차이점

UNION은 세로로 확장되지만 Cross JOIN은 가로로 확장

![스크린샷 2022-03-31 오후 8.32.18.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c56c1529-c68f-4a54-86a9-741517d6d928/스크린샷_2022-03-31_오후_8.32.18.png)

![스크린샷 2022-03-31 오후 8.32.28.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8342b458-2857-4521-bafb-db7b252bce3f/스크린샷_2022-03-31_오후_8.32.28.png)

### JOIN

기본키 ⇒ 집합에서 요소는 중복되지 않는 요소 ~ 데이터 역시 중복되지 않아야한다. → 기본키를 가지도록 권장 = 기본키는 하나의 데이터를 대표할 수 있는 속성

외부키 ⇒ 다른 테이블의 기본키를 참조하는 열

```sql
// cross join 이용 / 현재 권장 X
SELECT * FROM tableA, tableB
WHERE tableA.primaryKey = tableB.primaryKey

// inner join 이용
SELECT * FROM tableA
INNER JOIN tableB
ON tableA.primaryKey = tableB.primaryKey
```

### 관계형 모델

SQL ⇒ 관계형 모델을 기반으로 작성된 데이터베이스를 조작하는 체계적인 명령 집합

- Table = Relation
- Column = Attribute
- Row = Tuple

집합 연산이 릴레이션 연산과 대응한다. ⇒ 관계 대수

관계대수 규칙

- 하나 이상의 관계를 바탕으로 연산한다.
- 연산한 결과, 반환되는 것 또한 관계이다.
- 연산을 중첩 구조로 실행해도 상관없다.

자주 사용되는 관계대수 연산

- 합집합 : Union
- 차집합 : Except
- 교집합 : Intersect
- 곱집합 : Cross Join
- 선택 : Selection(조건에 따라 일부 튜플만 추출)
- 투영 : Projection(속성을 일부만 추출)
- 결합 : JOIN

## 데이터베이스 설계

데이터베이스 설계 ⇒ 데이터베이스 객체 정의 ⇒ 스키마 설계

논리명 ⇒ 설계할 때 사용 / 변경하기 쉬움

Ex) 상품 코드

물리명 ⇒ 실제 쿼리문에 작성될 때 사용 / 변경하기 어려움

Ex) product_code

테이블 정의서에서는 열명, 논리명 / 자료형 / 고정길이, 가변길이 / 기본키 등을 명시한다. (별도의 코멘트도 추가할 수 있음)

테이블간의 관계를 표현하기 위해 `ER다이어그램` 사용

ER 다이어그램 ⇒ 설계상으로 테이블이 이렇게 연관되어 있다~ 느낌으로 보여줌

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c7f86cbc-e5eb-41aa-a545-39ae4fd18045/Untitled.png)

### 정규화

- 테이블을 올바른 형태로 변경하고 분할하는 것을 정규화라고 한다.
- 주로 설계단계에서 이뤄짐
- 보통 제 5정규화 중 제 3정규화까지 채택

예시

| 주문상품                    |
| --------------------------- |
| 0001 00 1개, 0002 ㅁㅁ 10개 |
| 0001 00 4개, 0002 ㅌㅌ 12개 |

주문 상품 컬럼 하나에 다양한 정보들이 들어가 있다.

**제 1정규화 ⇒ 반복되는 부분을 찾아서 테이블 분할과 기본키 지정이 이루어진다.**

1.  반복되는 데이터를 행을 추가하기

    | 주문상품 | 상품명 | 개수 |
    | -------- | ------ | ---- |
    | 0001     | 00     | 1    |
    | 0002     | ㅁㅁ   | 10   |
    | 0001     | 00     | 4    |
    | 0002     | ㅁㅁ   | 12   |

2.  주문 상품 테이블을 새로 만든다.

| 주문상품 | 상품명 | 개수 | 주문번호 |
| -------- | ------ | ---- | -------- |
| 0001     | 00     | 1    | 1        |
| 0002     | ㅁㅁ   | 10   | 1        |
| 0001     | 00     | 4    | 2        |
| 0002     | ㅁㅁ   | 12   | 2        |

| 주문번호 | 날짜 | 성명   |
| -------- | ---- | ------ |
| 1        | 1/1  | 홍길동 |
| 2        | 2/1  | 김철수 |

**제 2정규화 ⇒ 부분 함수종속성(키 값을 이용해 데이터를 특정 지을 수 있는 속성)을 찾아내서 테이블을 분할한다. / 기본키에 중복이 있는지 조사**

| 주문번호 | 주문상품 | 상품명 | 개수 |
| -------- | -------- | ------ | ---- |
| 1        | 0001     | 00     | 1    |
| 1        | 0002     | ㅁㅁ   | 10   |
| 2        | 0001     | 00     | 4    |
| 2        | 0002     | ㅁㅁ   | 12   |

상품명과 개수는 주문이 특정되어야지 알 수 있다. ⇒ 별도의 테이블로 분리 가능

| 주문번호 | 주문상품 | 개수 |
| -------- | -------- | ---- |
| 1        | 0001     | 1    |
| 1        | 0002     | 10   |
| 2        | 0001     | 4    |
| 2        | 0002     | 12   |

| 주문상품 | 상품명 |
| -------- | ------ |
| 0001     | 00     |
| 0002     | ㅁㅁ   |

⇒ 주문 상품만으로도 상품명을 알 수 있기 때문에 분리

**제 3정규화 ⇒ 기본키 이외의 부분에서 중복이 없는지 조사**

| 주문번호 | 날짜 | 성명   |
| -------- | ---- | ------ |
| 1        | 1/1  | 홍길동 |
| 2        | 2/1  | 김철수 |
| 3        | 1/22 | 홍길동 |

홍길동이라는 사람이 반복해서 주문을 하고 있다. ⇒ 분리 가능

| 주문번호 | 날짜 | 고객 번호 |
| -------- | ---- | --------- |
| 1        | 1/1  | 1         |
| 2        | 2/1  | 2         |
| 3        | 1/22 | 1         |

| 고객 번호 | 성명   |
| --------- | ------ |
| 1         | 홍길동 |
| 2         | 김철수 |
| 1         | 홍길동 |

> 정규화 목적 ⇒ 하나의 데이터가 한 곳에만 저장되도록 하기 위함

⇒ 한번만 변경할 수 있기 때문

⇒ 기본키는 분할한 테이블끼리 연계하기 위해 작성된 내부적인 데이터이므로 변경될 일이 없어서 상관 X

### 트랜잭션

만약 은행 입출금을 예시로 들 때

상대방에게 입금을 하는 과정 중 오류가 발생하여 내 돈은 출금됐지만 상대방에게 입금이 안됐다면?

그렇다면 데이터베이스에서 번거롭게 롤백과정을 거쳐야한다.

⇒ 트랜잭션을 사용하면 작업단위로 쿼리문이 묶이고 오류가 발생하면 쉽게 롤백 과정을 처리해줘서 편리하게 사용할 수 있다.
