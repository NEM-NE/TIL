# 1주차 정리

## **쿠버네티스란?**

⇒ **컨테이너화된 애플리케이션을 효율적으로 배포 & 운영하기 위해 설계된 오픈소스 플랫폼**

구글 사내 운영시스템인 Borg에서 시작되었으며 이후 CNCF(Cloud Native Computing Foundation)가 주도하고 있다.

### 왜 사용하는가?

- 고객의 요구사항을 빈번하게 변하고 있으며 이를 빠르게 캐치해서 반영하는게 곧 서비스의 성장으로 이어짐.
  그래서 뜨고 있는 개발 방식이 `CI/CD(지속적 통합/지속적 배포)`
- 그러나 개발자들 간에 오픈소스 버전이 안맞거나 개발환경이 달라서 개발 생산성과 안정성이 떨어지고 있음
- 그래서 **컨테이너 기술을 통해 애플리케이션 실행에 필요한 라이브러리나 운영체제 패키지 등을 모두 담아서 불변의 실행 환경을 만든다.**
- 쿠버네티스를 통해 수십명에서 수백만명의 유저까지 쉽게 대응 가능한 확장성과 가용성 제공

### 기능

- 배포 계획에 맞춰 애플리케이션을 신속하게 배포한다.
  - 컨테이너 개수, CPU 사용률, 메모리 사용량 설정 가능
  - 저장 공간, 네트워크 접근 제어, 로드밸런싱 기능 설정 가능
- 가동 중인 애플리케이션을 스케일 업/다운할 수 있다.
  - 요청이 많을 때는 **컨테이너 수를 늘려서 처리능력을 높임**
  - 요청이 적을 때는 **컨테이너 수를 줄여 자원 점유율이나 요금을 줄임**
- 새로운 버전의 애플리케이션을 **무정지**로 업그레이드 할 수 있다.
- 하드웨어 가동률을 높여 자원 낭비를 줄인다.

### 특징

- 다양한 환경에서 쿠버네티스 사용 가능
  - 퍼블릿, 프라이빗, 하이브리드, 온프레미스 등 다양한 환경에서 사용 가능
- 계속되는 변화를 전제로 설계된 높은 유연성과 확장성
  - MSA에 최적화된 실행환경
  - 느슨한 결합에 의한 유연성, 교체 용이성
  - 다양한 스펙의 서버가 혼재하는 클러스터 구성에 사용 가능
  - 서버의 정지, 추가, 제거가 용이
  - 퍼블리 클라우드 API와 연동한 쿠버네티스 조작
- 고가용성과 성능 관리
  - 서버 정지 시 애플리케이션 재배포 자동화
  - 애플리케이션의 이상 중단 시 재시동 자동화
  - 필요한 인스턴스의 개수를 유지
  - 높은 부하에서 자동 스케일업

### 아키텍처

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b3485070-abd9-410a-97ba-42082ad5af9c/Untitled.png)

- 마스터와 노드로 구성
- 마스터는 kubectl과 같은 API 클라이언트로부터 요청을 받아서 애플리케이션 배포, 스케일 업/다운, 컨테이너의 버전 업 등의 요구를 처리한다. 마스터는 K8s 클러스터의 단일 장애점이 되지 않도록 다중화 할 수 있다.
- 유저 액세스 트래픽에 따라 노드를 추가/제거를 할 수 있으며 이는 애플리케이션 실행 중에도 가능하다.
- K8s 외부에 레지스터가 있으며, 각 노드에서 이미지를 다운로드 할 수 있도록 네트워크상 접근 가능한 곳에 있어야한다.

### 마무리

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3e817a3c-b331-405c-b85b-3ac0f8f61ed8/Untitled.png)

## 컨테이너의 이해

### 컨테이너를 사용하는 이유

1. 인프라 사용률 향상
   1. 하나의 서버 위에 여러개의 컨테이너를 돌릴 수 있다. ⇒ CPU와 메모리 사용률을 높혀 효율적으로 이용
2. 빠른 기동 시간
   1. 컨테이너의 기동 시간은 가상 서버나 물리 서버보다 훨씬 빠르다.
   2. 운영체제, 애플리케이션, 미들웨어 등 다양한 이미지를 쉽게 얻을 수 있다.
   3. 설치 작업이나 설정 작업이 줄어든다.
3. 불변 실행 환경
   1. 애플리케이션 실행에 필요한 소프트웨어를 모두 포함하여 컨테이너를 작성할 수 있다.
   2. 컨테이너를 조합하여 서버를 구성함으로써 특정 환경에 대한 종속성을 배제할 수 있다.
   3. 개발 환경과 운영 환경의 차이를 줄일 수 있다.

### 가상 서버 VS 컨테이너

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/84fded46-8cf8-4aba-bcd9-fd6013cd4807/Untitled.png)

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7ac6a2f0-5882-420d-ae71-ac7d31311f6b/Untitled.png)

가상 서버

- 하이퍼바이저(운영체제와 가상머신의 리소스를 분리하는 기술)를 통해 실제 서버가 있는 것처럼 동작하게 해줌
- 호스트와 OS를 공유하지 않기 때문에 보안상 이점 존재

컨테이너

- 하나의 리눅스 프로세스가 마치 전용 서버에서 동작하고 있는 것처럼 분리 상태를 만들어 낸다.
- 리눅스 커널 기술 중 `네임스페이스`, `cgroup`이라는 기술을 사용하여 분리
- 하이퍼바이저 상의 가상 서버의 위에서도 동작함
- 가상 서버보다 속도도 빠르고 경량화 되어 있음

### 도커 아키텍쳐

도커는 리눅스에서 제공하는 기술로도 충분히 만들 수 있지만 이를 추상화해서 사용 편리하게 만들어 다양한 기능을 지원한다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/819fb62f-bb57-4890-839f-6ff67fe9373d/Untitled.png)

**도커 데몬**

- 도커 클라이언트의 요청을 처리하는 서버같은 존재
- 이미지, 오브젝트, 컨테이너, 볼륨, 네트워크 등을 관리
- 네트워크 너머에 있는 원격 클라이언트의 요청도 받을 수 있다.

**도커 클라이언트**

- CLI 형태로 요청을 하는 클라이언트 같은 존재

**이미지**

- 컨테이너의 템플릿
  - docker pull을 하면 레지스트리에 있는 이미지가 로컬 리포지터리로 이동한다.
  - docker run을 하면 로컬 리포지터리 이미지를 기반으로 컨테이너를 생성한다.

**컨테이너**

- 실행 가능한 이미지의 인스턴스 / 하나의 프로세스
- 만약 Nginx 컨테이너를 만들 때 데비안 이미지가 필요하다면 레지스트리로부터 다운을 받고 컨테이너를 만든 이후에 Nginx 패키지를 그 위에 설치하는 작업 과정을 거친다.
- IP 주소를 가지는 하나의 독립된 서버처럼 동작한다.

**레지스트리**

- 컨테이너의 이미지가 보관되는 곳
- 레포지터리 ⇒ 하나의 이미지에 대해 태그를 사용하여 버전을 함께 보관하는 곳
- 퍼블릭, 클라우드, 프라이빗 레지스트리로 나뉜다. (Dockerhub는 퍼블릭 레지스트리)

### 레지스트리와 쿠버네티스의 관계

쿠버네티스도 레지스트리에서 이미지를 다운받아 컨테이너를 실행한다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/96f56962-a781-4706-b3f4-ad05863297a4/Untitled.png)

### 도커와 쿠버네티스의 연동

쿠버네티스는 도커를 컨테이너의 런타임 환경으로 사용한다. ⇒ 도커를 통해 컨테이너를 띄운다.

containerd ⇒ 이미지 보관 및 전송, 컨테이너 실행, 볼륨과 네트워크 연결과 같은 컨테이너의 라이프 사이클을 사용할 수 있게 해줌 / 컨테이너를 실행 시킬 수 있는 환경

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3ab2aa4c-6744-48f2-9ffc-1297c913bbe7/Untitled.png)

### 컨테이너를 위한 기술과 표준

다양한 리눅스 배포판에 따른 커널 버전이 존재하지만 리눅스 배포판과 커널 버전이 달라도 컨테이너는 정상 동작한다.

LBS는 소스코드를 컴파일해서 호환성 있는 머신코드로 생성

ABI는 리눅스 커널 버전이 올라가도 유저 공간에서 동작하는 바이너리 레벨(머신코드)의 호환성은 유지

리눅스 커널 기술

- 네임스페이스 ⇒ 컨테이너가 하나의 독립된 서버와 같이 동작할 수 있게 한다.
  - pid, net, ipc, mnt, uts를 통해 프로세스, 네트워크 인터페이스, 프로세스, 파일 시스템 등을 호스트로부터 분리
- cgroup ⇒ 프로세스 별로 CPU 시간이나 메모리 사용량과 같은 자원을 감시하고 제한한다.

유니온 파일 시스템 ⇒ 여러개의 이미지가 독립적으로 유지하며 합쳐질 수 있도록 해줌

OCI

### 마무리

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/09928763-7a42-445c-a337-4cd1351683e6/Untitled.png)
