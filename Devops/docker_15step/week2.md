# 2주차 정리

## 쿠버네티스의 기본

### 아키텍처

![IMG_BA2B84FC3191-1.jpeg](2%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%20e35d179069da4d3cbd9c25aefefef56a/IMG_BA2B84FC3191-1.jpeg)

위 아키텍처를 통해 크게 3가지의 계층으로 나눌 수 있다.

클라이언트 / 마스터 / 노드

클라이언트 ⇒ 개발자 / 운영자를 의미 

- 오브젝트 생성/변경/삭제를 요구
- 오브젝트의 상태 조회

마스터

- K8s 클러스터 관리
- 파드(컨테이너) 관리

노드

- 컨테이너 실행 환경

각 코어 프로세스의 역할

![Untitled](2%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%20e35d179069da4d3cbd9c25aefefef56a/Untitled.png)

etcd에 대한 추가 설명 : **클러스터에 어떤 노드가 몇 개나 있고 어떤 파드가 어떤 노드에서 동작하고 있는지가 저장됨.** 즉, 동작 중인 클러스터의 etcd 데이터베이스가 유실된다면 컨테이너뿐만 아니라 클러스터가 사용하는 모든 리소스가 미아가 되어 버린다.

kube-proxy에 대한 추가 설명: **클러스터 내의 한 포드에서는 클러스터의 모든 포드로 요청을 보낼 수 있다.**

그러나 포드는 일시적이며 그에 따라 주소가 변경된다. 그래서 service를 통해 해결할 수 있는데 service는 사실 actual thing이 아니며 이를 가능하게 하는 것이 kube-proxy이다. **Kube-proxy는 새로운 서비스를 찾고, 찾을 때 마다 각 포드로 갈 수 있는 rule을 형성해준다.**

[Kubernetes 운영을 위한 etcd 기본 동작 원리의 이해](https://tech.kakao.com/2021/12/20/kubernetes-etcd/)

![Untitled](2%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%20e35d179069da4d3cbd9c25aefefef56a/Untitled%201.png)

### 쿠버네티스 API 오브젝트

쿠버네티스 API

- 쿠버네티스에 대한 조작은 모두 API를 통해 이뤄짐.
- 쿠버네티스 API 규약에 따른 매니페스트가 kube-apiserver에게 YAML, JSON 형식으로 전달하여 조작

오브젝트

- **K8s 내부 엔티티로서 파드, 컨트롤러, 서비스 등의 인스턴스를 의미**
- **지정된 상태가 유지되도록 쿠버네티스에 의해 제어**
- 오브젝트를 만들 때는 반드시 이름을 부여해야한다. (이름으로 식별 / 네임스페이스안에 동일한 종류의 오브젝트는 중복된 이름을 가질 수 없다.)

워크로드

- 오브젝트의 카테고리 / Ex) 컨테이너와 파드, 컨트롤러의 그룹 등
- 컨테이너의 실행을 관리하기 위해 사용

컨테이너

- 반드시 파드 위에서만 실행 가능
- 이미지의 이름, 실행 명령어, 실행 인자, 환경 변수, 볼륨, CPU 사용 시간, 메모리 크기의 요청값, 상한값 등을 설정 가능

**파드**

- 컨테이너를 담기 위한 오브젝트
- 여러개의 컨테이너를 담을 수 있음

**컨트롤러**

- **파드의 실행을 제어하는 오브젝트**
- 종류가 다양해서 기능을 명확히 알고 사용할 것
    - 디플로이먼트 컨트롤러 ⇒ 파드의 특정 개수를 유지
    - 잡 컨트롤러 ⇒ 배치 처리가 정상 종료 될 때까지 반복
    

**서비스**

- **파드와 클라이언트를 연결하는 역할**
- **클라이언트의 요청을 받을 수 있도록 대표 IP 주소를 취득하여 내부 DNS에 등록**
- 대표 IP주소로부터 온 요청을 부하분산 처리 가능

스토리지

- 컨테이너에 중요한 데이터 저장 X
- 데이터를 잃지 않기 위해서는 퍼시스턴트 볼륨을 사용(종료되어도 유지)
- 복수의 노드에서 접근 가능한 퍼시스턴트 볼륨은 쿠버네티스 범위에 포함 X → 외부 스토리지 서비스를 연동

### 파드

**파드의 통신**

- 파드 내부의 컨테이너들은 파드의 IP 주소와 포트번호를 공유한다.
- 파드의 내부 컨테이너들은 localhost로 서로 통신할 수 있다.
- 파드의 내부 컨테이너들은 System V 프로세스 통신이나 POSIX 공유 메모리를 사용하여 통신할 수 있다.
- 파드의 내부 컨테이너들은 파드의 볼륨을 마운트하여 파일 시스템을 공유할 수 있다.

→ 같은 파드 내의 컨테이너들만 가능

**파드는 일시적인 존재**

- 이미지로부터 매번 생성
- 컨테이너에서 수행한 변경 이력들은 기록 X & 이미지 초기 상태에서 시작
- 파드의 IP 주소도 고정적이지 X / 기동할 때 부여 & 종료할 때 회수 ⇒ **파드에 요청을 보내려면 반드시 서비스 이용**

**파드는 컨테이너의 실행 상태를 관리**

- **파드의 실행상태는 컨트롤러가, 컨테이너의 실행 상태는 파드가 관리한다.**
- 활성 프로브(Liveness Probe): 요청을 보내 제대로 된 응답이 안올 경우 컨테이너가 죽은 것으로 판단하여 컨테이너를 재시작한다.
- 준비 상태 프로브(Readliness Probe): 파드가 요청을 받을 준비가 될 때까지 서비스 오브젝트가 요청을 전송하지 않는다.

파드는 초기화 컨테이너 설정 가능

초기화 컨테이너를 설정하여 파드가 기동된 후 초기화 컨테이너가 먼저 실행되고 초기화가 끝나면 핵심 기능을 수행하는 컨테이너들이 실행된다.

### 파드의 라이프 사이클

후에 발생하는 에러를 빠르게 이해할 수 있다.

![Untitled](2%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%20e35d179069da4d3cbd9c25aefefef56a/Untitled%202.png)

### 파드의 종료 처리

종료 실행 → 유예 시간 대기(기본 30초) → 종료

애플리케이션이 동작 중 강제 종료되면 데이터 유실등의 이슈 발생 가능 ⇒ 애플리케이션의 메인 메모리 데이터를 퍼시스턴트 볼륨에 저장하거나 데이터베이스 세션을 종료시키는 등의 종료 처리를 수행해야한다.

종료 처리 흐름

1. kubectl delete pod를 실행하면 파드의 종료처리가 시작.
2. status는 Terminating으로 전환
3. 3가지 작업 동시 진행
    1. 파드의 PreStop Hook이 정의되어 있으면 파드 내에 호출, 단 유예시간이 넘으면 메인 프로세스에 SIGTERM(프로세스를 안전하게 종료하는 방식)신호가 송신 2초 후 강제 종료 By SIGKILL(프로세스 강제 종료)
    2. 파드의 PreStop Hook가 없다면 곧바로 파드 내의 메인 프로세스에 SIGTERM신호가 송신 & 종료 처리 개시
    3. 파드가 서비스의 엔드포인트 목록에 제거 & 로드밸런서 목록에도 제거
4. 유예시간이 넘으면 파드의 메인 프로세스에 SIGKILL로 강제 종료
5. 파드가 사라짐

### 클러스터 네트워크

⇒ K8s 클러스터 내부에 사용되는 네트워크 파드는 이 네트워크 상의 IP 주소를 부여받아 다른 노드에 있는 파드와 통신

- Flannel
- Calico

### 서비스

**파드는 매번 기동될 때마다 대표 IP가 바뀌므로 서비스를 통해 통신을 해야한다.** 

![Untitled](2%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%20e35d179069da4d3cbd9c25aefefef56a/Untitled%203.png)

1. **서비스는 로드밸런서의 역할을 가지며, 클라이언트의 요청을 받기 위한 대표 IP 주소를 획득한다.**
2. 서비스의 이름은 내부 DNS에 등록되기 때문에 클라이언트는 **서비스의 이름만으로 서비스의 IP 주소획득가능**
3. 서비스는 셀렉터에 지정된 라벨과 일치하는 파드 중 하나에게 요청을 전달한다.
    
    **파드는 기동될 때 라벨, IP 정보를 마스터 노드 프로세스 중 하나인 etcd에 저장** 이후 etcd에서 조회하여 파드의 IP 주소 획득
    
4. 기동된 파드의 컨테이너에는 서비스에 대한 정보가 담긴 환경 변수가 자동으로 설정된다.
5. 클라이언트 범위에 따라 4종류의 서비스가 존재하며 클러스터 내부, 외부, 외부의 IP주소 등으로 나뉨.

**중요 키워드**

- 대표 IP 주소 ⇒ 파드의 그룹을 대표하여 클라이언트의 요청을 받기 위해 가짐
- 부하분산 ⇒ 서비스는 셀렉터에 지정된 라벨과 일치하는 파드 중 하나에게 요청을 전달한다.
- 이름 해결 ⇒ 서비스의 이름은 내부 DNS에 등록되기 때문에 클라이언트는 서비스의 이름만으로 서비스의 IP 주소획득가능
- 환경 변수 ⇒ 기동된 파드의 컨테이너에는 서비스에 대한 정보가 담긴 환경 변수가 자동으로 설정된다. → 서비스의 IP주소도 얻을 수 있다.
- 어피니티 ⇒ 부하분산에 사용되는 알고리즘은 랜덤 but 파드 고정 가능
- 셀렉터와 라벨
    - 라벨 : 파드등의 오브젝트가 가지는 키값
    - 셀렉터 : 라벨에 대한 조건

### 컨트롤러

→ 파드를 제어하기 위해 사용

![Untitled](2%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%20e35d179069da4d3cbd9c25aefefef56a/Untitled%204.png)

워크로드 타입별 처리

- 프론트엔드
    
    클라이언트의 요청을 직접 받아들임 → 대량의 요청을 받아 짧은 시간안에 응답을 해야함
    
    요청을 복수의 파드가 부담하도록 설정 필요
    
    24시간 무정지로 서비스를 제공하는 설정 필요
    
- 백엔드
    
    프런트엔드의 뒤에서 업무의 특성에 맞게 대응할 수 있는 유연성이 있어야한다.
    
    활용성
    
    1. 데이터 스토어 → DB, cloudDB
    2. 캐시 → 복수 파드에서 데이터 공유(세션 정보 공유)
    3. 메시징 → 비동기 시스템 간 연계 가능성(메시지 브로커)
    4. 마이크로 서비스 → 전문적 업무 기능 구현(결제, 배송)
    5. 배치 처리 → 긴 처리 시간을 요하는 업무 기능(ML, 데이터분석)
- 배치 처리(정기 실행 처리 포함)
    
    배치 처리는 어떤 트리거에 의해 실행이 게시된다.
    
- 시스템 운영 처리
    
    시스템 운영을 돕기 위해 쿠버네티스 API를 사용해서 노드에서 발생하는 에러나 하드웨어 이상을 감지하고 자동으로 대책을 실행하는 파드를 만드는 경우
    

컨트롤러 타입

- 디플로이먼트
- 스테이트 풀셋
- 잡
- 크론잡
- 데몬셋
- 레플리카셋

![Untitled](2%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%20e35d179069da4d3cbd9c25aefefef56a/Untitled%205.png)

### 마무리

![Untitled](2%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%20e35d179069da4d3cbd9c25aefefef56a/Untitled%206.png)