# 4주차 정리

## K8s 사용자를 위한 YAML 입문

```yaml
apiVersion: v1
kind: Pod
metadata:
	name: nginx
spec:
	containers:
	- name: nginx
		image: nginx:latest -> [{name: nginx, image: nginx:latest}]
```

apiVersion이란?

1. 키 : 값으로 구성
2. 들여쓰기로 복합적 데이터 구조를 나타낸다. Ex) metadata → name
3. “-” 표시는 배열을 나타내는데 만약 다음 줄에 - 이 없는 경우 동일한 인덱스에 속하는 걸로 인식한다.

## 쿠버네티스 환경 구축

→ 클러스터 환경을 구축하려면 여러 노드들이 필요(아마 실제 인스턴스 환경일 듯)

- 정석적으로 인스턴스들을 이용하여 구축하기
    
    [[Kubernetes] 쿠버네티스 클러스터 구축](https://dongle94.github.io/kubernetes/kubernetes-cluster-build/)
    
- Minikube 사용하기
    
    [Mac OS에서 minikube 사용하기 Part 1](https://judo0179.tistory.com/70)
    
    [Minikube(미니큐브)](https://sharplee7.tistory.com/86)
    
- Docker desktop 쿠버네티스 사용하기 (요것도 어차피 싱글스레드여서 미니쿠베와 같다.)
    
    [쿠버네티스 클러스터 구축하기 (2) Docker Desktop](https://gurumee92.tistory.com/300?category=977986)
    

# 쿠버네티스 첫걸음

![Untitled](4%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%20a70b1c65cb1d4c2aa029251a3d839969/Untitled.png)

1. K8s 클러스터를 조작하기 위해 사용하는 커맨드
2. 컨테이너 실행을 명령하는 서브 커맨드
3. 쿠버네티스 오브젝트의 이름(파드나 컨트롤러 등)
4. 컨테이너의 이미지 이름을 지정 (디폴트 리포지토리는 도커 허브)
5. 도커 -it와 마찬가지로 i는 표준 입력, t는 터미널 대화모드 설정
6. 파드의 기동 방법 변경(Never는 파드가 직접, Always, OnFailure는 컨트롤러를 통해 파드가 기동)

위 명령어를 실행하면 이미 존재하는 파드로 생성이 안됨 → 종료한 파드가 남아있기 때문이다.

![스크린샷 2022-05-06 오후 4.56.52.png](4%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%20a70b1c65cb1d4c2aa029251a3d839969/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-05-06_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_4.56.52.png)

+) `kubectl get pod` 는 `docker ps -a`처럼 종료 상태를 포함한 컨테이너를 보여준다.

`kubectl delete pod hello-world`를 통해 삭제하고 다시 명령어를 실행하면 정상적으로 동작한다.

+) `kubectl logs hello-world`를 통해 로그를 확인할 수 있다.

+) kubectl run ~~ 명령어에 `—rm` 옵션을 추가해주면 도커와 마찬가지로 종료된 후에 삭제된다.

![Untitled](4%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%20a70b1c65cb1d4c2aa029251a3d839969/Untitled%201.png)

1. kubectl이 쿠버네티스에게 명령 전달
2. 노드에 이미지가 없다면 도커허브에서 이미지 다운로드
3. **노드의 containerd가 컨테이너를 실행한다.**
4. kubectl이 터미널에 메시지를 표시한다.

### 컨트롤러에 의한 파드 실행

→ 기존 `kubectl run ~`에 옵션을 지정하면 파드를 `디플로이먼트 컨트롤러`의 제어하에 실행하는 것이 가능하다.

![스크린샷 2022-05-06 오후 4.56.52.png](4%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%20a70b1c65cb1d4c2aa029251a3d839969/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-05-06_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_4.56.52.png)

—restart=Never 대신 —restart=Always로 하면 된다. (혹은 기본 값이 Always이기 때문에 생략해도 된다.)

+) kubectl run 보다는 `kubectl create deployment hello-world —image=hello-world`를 권장

+) deployment는 백그라운드에서 무조건 실행하기 때문에 -it 옵션은 무시한다.

![스크린샷 2022-05-06 오후 8.47.35.png](4%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%20a70b1c65cb1d4c2aa029251a3d839969/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-05-06_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_8.47.35.png)

- deployment.apps/hello-world : 디플로이먼트 오브젝트로 이름은 hello-world이며, **이 컨트롤러는 레플리카셋 컨트롤러와 함께 파드를 관리하여 이미지의 버전, 파드의 개수 등이 목표 상태가 되도록 관리한다.

디플로이먼트의 역할**
    1. Pod의 scale in / out 되는 기준을 정의한다.
    2. Pod의 배포되고 update 되는 모든 버전을 추적할 수 있다.
    3. 배포된 Pod에 대한 rollback을 수행할 수 있다.
    
    **Deployment = ReplicaSet +Pod+history이며 ReplicaSet 을 만드는 것보다 더 윗 단계의 선언(추상표현)이다.**
    
- replicaset.apps/hello-world-649b9bfb9c : 레플리카셋 컨트롤러 오브젝트로, 디플로이먼트와 함께 파드의 수가 지정한 개수가 되도록 제어한다. (레플리카셋을 직접 조작하는 것은 권장 X)
디플로이먼트 오브젝트 이름 뒤에 고유한 해쉬값이 추가됐다.
레플리카셋 컨트롤러란 Replication Controller의 새로운 버전으로 Label Selector를 통해 **노드 상의 여러 Pod의 생성/복제/삭제 등의 라이프 싸이클을 관리**
- pod/hello-world-649b9bfb9c-8kj5r : 파드 안에는 하나 혹은 여러 개의 컨테이너가 실행된다. 또한 유일한 이름을 부여받기 위해 레플리카셋 컨트롤러 오브젝트의 이름에 추가로 해쉬값이 추가됐다.
    
    +) `kubectl logs pod/hello-world-649b9bfb9c-8kj5r`를 통해 로그를 확인할 수 있다.
    

![스크린샷 2022-05-06 오후 8.59.37.png](4%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%20a70b1c65cb1d4c2aa029251a3d839969/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-05-06_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_8.59.37.png)

위 명령어를 통해 현재 상태를 보면 다음과 같다.

![Untitled](4%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%20a70b1c65cb1d4c2aa029251a3d839969/Untitled%202.png)

deployment.apps/hello-world는 최근에 업데이트된 파드의 개수는 1개이며, 사용가능한 파드의 개수는 0개이고 $실행가능한 파드의 개수/전체 파드의 개수$에 대한  수를 나타낸다.

![Untitled](4%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%20a70b1c65cb1d4c2aa029251a3d839969/Untitled%203.png)

pod/hello-world-649b9bfb9c-8kj5r는 현재 CrashLoopBackOff 상태이며, 7번째 재시작되었다.

+) 추가

![Untitled](4%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%20a70b1c65cb1d4c2aa029251a3d839969/Untitled%204.png)

위 에러가 발생하는 이유 → hello-world 이미지는 단순히 글자를 출력을 하고 종료되는 이미지이기 때문에 계속 파드를 새로 생성하기 때문이다.

현재 포드는 **디플로이먼트 컨트롤러에 맞지 않는 워크로드를 가진다.**

디플로이먼트 컨트롤러에 적합한 워크로드인 웹 서버를 이미지로 실행

![스크린샷 2022-05-06 오후 9.08.02.png](4%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%20a70b1c65cb1d4c2aa029251a3d839969/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-05-06_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_9.08.02.png)

이전과는 다르게 정상적으로 동작한다.

![스크린샷 2022-05-06 오후 9.08.39.png](4%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%20a70b1c65cb1d4c2aa029251a3d839969/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-05-06_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_9.08.39.png)

특정 파드를 삭제하면 새로 생성되는 것을 확인할 수 있다. 또한 기존 파드를 재시동하는 것이 아닌 새로운 파드가 생성된다. → **컨테이너의 애플리케이션은 기본적으로 상태가 없어야한다.**

![스크린샷 2022-05-06 오후 9.10.37.png](4%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%20a70b1c65cb1d4c2aa029251a3d839969/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-05-06_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_9.10.37.png)

### 잡에 의한 파드 실행

hello-world 컨테이너는 단발성 워크로드이다. 여기에 적합한 컨트롤러는 잡 컨트롤러로 파드가 비정상 종료하면 재시작하며 파드가 정상종료 할 때까지 지정한 횟수만큼 재실행한다.

![스크린샷 2022-05-06 오후 9.26.37.png](4%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%20a70b1c65cb1d4c2aa029251a3d839969/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-05-06_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_9.26.37.png)

정상 종료된 hello-world, 에러가 발생되어 계속 재시동하는 error-job 파드

### 마무리

![Untitled](4%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%20a70b1c65cb1d4c2aa029251a3d839969/Untitled%205.png)

### 추가) 파드와 컨트롤러의 관계

![Untitled](4%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%20a70b1c65cb1d4c2aa029251a3d839969/Untitled%206.png)

# 매니페스트와 파드

`매니페스트` → 쿠버네티스의 오브젝트를 생성하기 위한 메타정보를 YAML, JSON으로 기술한 파일

실제로 파드 단독을 위한 매니페스트보다는 컨트롤러에 대한 메니페스트를 작성한다. 그러나 파드에 대한 정보를 기술하는 `파드 템플릿`이라는 부분이 존재하고 이는 파드의 매니페스트와 같다.

### 매니페스트 작성법 및 사용하기

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: nginx
spec:
  containers:
  - name: nginx
    image: nginx:latest
```

YAML

```json
{
    "apiVersion": "v1",
    "kind": "Pod",
    "metadata": {
	"name": "nginx"
    },
    "spec": {
        "containers": [
            {
                "image": "nginx:latest",
                "name": "nginx"
            }
        ]
    }
}
```

JSON

매니페스트를 작성하기 위해 필요한 키값에 대한 정보는 쿠버네티스 공식 API문서에 기재되어 있다.

[Kubernetes API Reference Docs](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#-strong-api-overview-strong-)

![Untitled](4%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%20a70b1c65cb1d4c2aa029251a3d839969/Untitled%207.png)

파드의 사양 주요 항목을 볼 수 있으면 알 수 있다시피 여러개의 컨테이너, 초기화 컨테이너, 볼륨들을 설정할 수 있다.

### 파드의 동작 확인

![스크린샷 2022-05-06 오후 10.36.36.png](4%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%20a70b1c65cb1d4c2aa029251a3d839969/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-05-06_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_10.36.36.png)

매니페스트를 기반으로 파드를 생성할 수 있는 것을 확인 할 수 있다. 또한 nginx 파드는 nginx이미지를 기반으로 현재 `클러스터 네트워크` 80번 포트에서 대기 중이다. 

**`클러스터 네트워크(파드 네트워크)`란 K8s 클러스터를 구성하는 “노드” 간의 통신을 위한 폐쇄형 네트워크이다.**

→ 클러스터를 호스팅하는 컴퓨터에서도 접근할 수 없으며 오로지 클러스터 내에 노드를 위한 네트워크이다.

→ -o wide 옵션을 통해 주소를 확인해서 호스팅 컴퓨터에서 접속해도 응답이 안된다.

→ **외부에서 클러스터 네트워크에 있는 파드의 포트에 접근하기 위해서는 `서비스`를 이용해야한다.**

**파드는 클러스터 네트워크상의 IP 주소를 가지며 이 주소를 바탕으로 파드와 파드가 서로 통신할 수 있다.**

### 파드의 헬스 체크 기능

→ 파드의 컨테이너에는 애플리케이션이 정상적으로 기동 중인지 확인하는 기능인 헬스 체크 기능이 존재한다.

헬스체크의 기능을 통해 컨테이너를 재시동하거나 강제종료를 시킬 수 있다.

기존 방식

- 로드밸런서가 주기적으로 요청을 보내 서버가 정상적으로 동작하는지 확인
- 만약 정상적으로 동작하지 않는다면(500에러를 계속 반환) 해당 서버를 제외한 채로 다른 서버에게 요청을 보낸다.

이에 반해 쿠버네티스는 kubelet를 통해 헬스체크를 한다.

![Untitled](4%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%20a70b1c65cb1d4c2aa029251a3d839969/Untitled%208.png)

kubelet의 헬스 체크는 다음 두 종류의 프로브를 사용하여 실행 중인 파드의 컨테이너 상태를 검사한다.

- 활성 프로브 : 어플리케이션이 정상 기동 중인지 확인 / 실패하면 컨테이너를 강제 종료 후 재시작 / 매니페스트에 명시적으로 기재해야 사용
- 준비상태 프로브 : 어플리케이션이 요청을 받을 준비가 됐는지 확인 / 실패하면 요청 트래픽 전송을 중지 / 기동 ~ 요청 준비 사이에서 오는 요청을 막기 위해 사용 / 매니페스트에 명시적으로 기재해야 사용

이러한 헬스 체크를 하기 위해서는 프로브의 핸들러를 추가해야한다. 핸들러의 종류로는 http 요청을 보내 확인하는 방식, 컨테이너 내 커맨드를 실행하는 방식, TCP 포트번호로 연결하여 확인하는 방식 등이 있다.

![Untitled](4%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%20a70b1c65cb1d4c2aa029251a3d839969/Untitled%209.png)

httpGet 방식을 적용한 예

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: webapl
spec:
  containers:
  - name: webapl
    image: dlatqdlatq/webapl:0.1    # (1)핸드러를 구현한 애플리케이션 
    livenessProbe:            # (2)애플리케이션이 살아있는지 확인
      httpGet:
        path: /healthz        # 확인 경로 - 직접 구현한다.
        port: 3000
      initialDelaySeconds: 3  # 검사 개시 대기 시간
      periodSeconds: 5        # 검사 간격
    readinessProbe:           # (3) 애플리케이션이 준비되었는지 확인
      httpGet:
        path: /ready          # 확인 경로 - 직접 구현한다.
        port: 3000
      initialDelaySeconds: 15
      periodSeconds: 6
```

![Untitled](4%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%20a70b1c65cb1d4c2aa029251a3d839969/Untitled%2010.png)

위 YAML 파일을 실행 시키면 실제로 지정된 시간마다 요청을 보낸다.

![스크린샷 2022-05-06 오후 11.25.57.png](4%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%20a70b1c65cb1d4c2aa029251a3d839969/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-05-06_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_11.25.57.png)

`kubectl describe pod webapl`를 사용하며 파드의 구체적인 정보를 확인할 수 있다.

![스크린샷 2022-05-06 오후 11.26.13.png](4%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%20a70b1c65cb1d4c2aa029251a3d839969/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-05-06_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_11.26.13.png)

또한 Events에 대한 정보도 확인할 수 있다. → 실제로 활성상태 프로브가 실패하여 재시동 한 것을 확인 할 수 있다.

![스크린샷 2022-05-06 오후 11.27.32.png](4%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%20a70b1c65cb1d4c2aa029251a3d839969/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-05-06_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_11.27.32.png)

### 초기화 전용 컨테이너

**초기화 전용 컨테이너란?**

→ 파드의 앱 컨테이너들이 실행되기 전에 실행되는 특수한 컨테이너로 **앱 이미지에는 없는 유틸리티 또는 설정 스크립트 등을 포함할 수 있다.**

→ 초기화 컨테이너는 항상 완료를 목표로 실행된다. (실패할 경우 성공할 때까지 반복적으로 재시작)

→ **초기화 컨테이너는 앱 컨테이너의 리소스 상한(limit), 볼륨, 보안 세팅을 포함한 모든 필드와 기능을 지원한다.**

→ 초기화 컨테이너는 `lifecycle`, `livenessProbe`, `readinessProbe` 또는 `startupProbe`를 지원하지 않는다.

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: init-sample
spec:
  containers:
  - name: main           # 메인 컨테이너
    image: ubuntu
    command: ["/bin/sh"]
    args: [ "-c", "tail -f /dev/null"]
    volumeMounts:
    - mountPath: /docs   # 공유 볼륨 마운트 경로
      name: data-vol
      readOnly: false

  initContainers:        # 메인 컨테이너 실행 전에 초기화 전용 컨테이너를 기동 
  - name: init
    image: alpine
    ## 공유 볼륨에 디렉터리를 작성하고, 소유를 변경
    command: ["/bin/sh"]
    args: [ "-c", "mkdir /mnt/html; chown 33:33 /mnt/html" ]
    volumeMounts:
    - mountPath: /mnt    # 공유 볼륨 마운트 경로 
      name: data-vol
      readOnly: false

  volumes:               # 파드의 공유 볼륨
  - name: data-vol
    emptyDir: {}
```

`kubectl exec -it podName -c containerName /bin/bash` 로 파드내에 있는 특정 컨테이너에 접근

![스크린샷 2022-05-07 오전 12.52.59.png](4%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%20a70b1c65cb1d4c2aa029251a3d839969/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-05-07_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_12.52.59.png)

→ www-data가 html 폴더를 생성했다고 나온다.