객체지향의 사실과 오해 정리
===

## 목차

1. <b>협력하는 객체들의 공동체</b>
2. <b>이상한 나라의 객체</b>
3. <b>타입과 추상화</b>
4. <b>역할, 책임, 협력</b>
5. <b>책임과 메세지</b>
6. <b>객체 지도</b>
7. <b>함께 모으기</b>

----

<br><br><br>

## 협력하는 객체들의 공동체

<br>

> 객체지향의 핵심은 클래스, 메서드가 아니라 협력, 역할, 책임이다.

<br>

    지금 나는 카페에 가서 커피를 주문한다고 가정하자.
    카페에는 주문을 받는 캐시어, 커피를 제조하는 바리스타가 있다.

    손님인 나는 커피를 주문하게 되고 캐시어는 주문을 받고 나의 결제를 받고 있다.
    
    이후 주문을 받은 캐시어는 바리스타에게 주문을 알려주고 바리스타는 자신만의 방법으로 커피를 제조한다.

    제조된 커피는 다시 캐시어에게 전달되어 나에게 건네준다.

위 과정에서 커피 주문이라는 협력 안에서 손님, 캐시어, 바리스타의 역할이 존재하고 각 역할안에서 맡은 책임을 다하고 있다.

<br><br>

### 요청과 응답으로 구성된 협력

<br>

하나의 역할에서 모든일을 다 처리하기 버거우므로 다른 책임을 가지고 있는 역할에게 `요청`을 한다.

이 요청은 위 커피 주문처럼 `연쇄적`으로 일어나며 응답 역시 `연쇄적`으로 처리된다.

즉, 이러한 요청과 응답을 통해 다른 역할과 협력을 할 수 있게 해준다.

<br><br>

### 역할과 책임

<br>

협력 속에서 서로 다른 역할이 존재하고 그에 따른 특정한 책임이 존재한다.

이에 따라 중요한 개념을 제시하는데

* 여러 사람이 동일한 역할을 수행할 수 있다.
* 역할은 대체 가능하다.
* 책임을 수행하는 방법은 자율적이다.
* 한 사람이 동시에 여러 작업을 수행할 수 있다.

<br><br>

### 협력 속에 사는 객체

<br>

객체 지향 어플리케이션에서는 협력에 참여하는 주체는 객체, 요청/응답은 메세지, 처리하는 방법을 메서드라고 부른다.
또한 어플리케이션은 수 많은 객체들의 협력으로 이뤄지기 때문에 객체의 품질은 곧 어플리케이션의 품질을 의미한다.
따라서 객체의 품질을 올리기 위해서는 2가지 덕목을 따라야하는데

1. 객체는 충분히 협력적이어야 한다.  => 요청에 복종하는 것이 아닌 응답하는 것이다. (요청을 수행하는 것도 자율적으로..)
2. 객체는 충분히 자율적이어야 한다. => 스스로 결정하고 행동해야한다.


객체가 자율적인 존재가 되기 위해서는 `필요한 행동과 상태`를 가지고 있어야 하며 
사적인 부분은 다른 객체들이 모르게 하되 객체의 외부에서는 접근이 허락된 수단을 통해서만 소통해야한다. (외부의 요청을 표현하기 위한 메세지와 요청을 처리하는 메서드를 분리하는게 핵심)
이를 통해 유지보수가 쉽고 재사용성이 용이한 시스템을 구축할 수 있다.

<br><br>

### 정리

<br>

* 객체지향이란 시스템을 구성하고 있는 자율적인 객체들을 통해 시스템을 분리하는 방법이다.
* 자율적인 객체란 상태와 행동을 가지며 스스로 판단하고 행동하는 것을 의미한다.
* 객체는 시스템의 기능을 수행하기 위해 다른 객체들과 협력을 하며 협력 간에 각 객체들은 역할이 있고 역할은 서로 다른 책임들의 집합을 의미한다.
* 객체는 협력하기 위해 메세지를 다른 객체에게 보내고 받은 메세지를 처리하기 위해 자율적으로 메서드를 선택 후 처리한다.

<br><br>

----

<br><br><br>

## 이상한 나라의 객체

<br>

> 객체의 중요한 특성은 상태, 행동, 식별자이다.

객체는 인간의 인지 능력인에서 인식할 수 있는 모든 사물을 의미. (개념적인 내용도 포함)

    이상한 나라의 앨리스 이야기 중 앨리스는 토끼를 따라가던 중 자신의 크기로는 통과할 수 없는 문을 발견하고
    문을 통과하기 위해 주변에 있는 물병, 부채, 버섯, 케이크를 통해 자신의 크기를 조절할 수 있었고 
    이를 통해 문을 통과할 수 있었다

즉, 앨리스는 부채를 이용하여 키를 20cm를 줄일 수 있다. 부채질이라는 행동을 통해 앨리스 키의 상태를 변화 시키는 것이다.
또한 부채질을 통해 자신의 키 - 20cm로 변하는데 이는 앨리스의 행동의 결과는 상태에 의존적이라는 것을 나타낸다.

=> `행동은 상태를 변화시키지만 행동의 결과는 상태에 의존적이다.`

<br><br>

### 상태

<br>

상태는 왜 필요한가? => 행동의 결과를 쉽게 예측할 수 있기 때문에 필요하다.

상태와 프로퍼티 => 객체의 상태란 앨리스의 키는 130cm처럼 특징을 가지는데 여기서 앨리스의 키는 프로퍼티, 130cm는 프로퍼티 값이 된다. 또한 앨리스와 음료수 관계처럼 프로퍼티 값은 단순한 값이 될 수도 있지만 객체가 될 수 있다. (이를 링크라고 부름)

또한 `상태는 반드시 자신에 의해서만 변경 되야하며 다른 객체가 직접적으로 접근할 수도, 상태를 변경할 수도 없다.`

<br><br>

### 행동

<br>

협력에 있어 서로 다른 역할을 가진 객체 간에 의사소통이 필요한데 이는 오로지 메세지를 통해서만 가능하다.
메세지를 통해 요청을 받으면 행동을 통해 처리함으로써 협력에 기여한다. 

따라서 행동은 메세지를 받고 요청에 반응하기 위한 활동으로 행동의 결과에 의해 상태가 변경되거나 다른 객체에게 메세지를 보내기도 한다.

행동을 통해 객체의 상태를 변경할 수 있다. 이 때 Side Effect가 초래되며 행동의 결과는 상태에 의존적이다.

또한 상태는 다른 객체가 직접적으로 접근할 수 없는데 대신 캡슐화를 통해 간접적으로 접근이 가능하다. => 행동의 자율성을 높임

캡술화를 하면 상대방은 요청만 할 뿐 수신자의 자율적인 판단에 맡기기 때문에 행동의 자율성을 높여준다.

<br><br>

### 식별자

<br>

식별자는 객체의 프로퍼티 중 하나로 객체를 식별할 수 있게 해준다. 이는 모든 객체가 가지는 프로퍼티로 단순한 값은 프로퍼티를 가지지 않는다.

따라서 값의 같은지 확인할 때는 단순히 값만 비교하는 동등성을 확인하면 되지만 객체가 같은지 확인할 때는 식별자를 통해 동일성을 확인한다.

<br><br>

### 정리

<br>

객체의 특성

* 객체는 상태를 가지며 상태를 변경할 수 있다.
* 객체의 상태를 변경하는 것은 행동이다.
    * 객체는 행동의 결과는 상태에 의존적이다.
    * 행동의 순서가 결과에 영향을 미친다.
* 객체는 식별자에 의해 식별될 수 있다.

좋은 객체 지향 설계

    1. 상태를 결정하기 보다는 행동을 먼저 결정해라
    즉, 어플리케이션에 필요한 협력을 생각하고 협력에 필요한 행동을 생각한 후 행동을 수행할 객체를 선택한다.

    2. 은유 관계에 있는 실제 객체의 이름을 소프트웨어 객체의 이름으로 사용하면 쉽게 예측할 수 있다.

<br><br>

----

<br><br><br>
    
## 타입과 추상화

<br>

> 객체를 분류하는 타입은 행동에 의해 결정되며 타입을 통해 추상화를 할 수 있다.

    영국 런던에서 처음 지하철이 개통하고 승객들이 지하철 역을 쉽게 찾을 수 있도록 지하철 회사에서는 지하철 노선도를 만들게 된다.
    만들어진 지하철 노선도는 실제 지도 위에 그린 것처럼 지형과 거리를 반영해서 만들었다.
    그러나 승객들은 만들어진 노선도를 보고 지하철 역을 찾기 힘들었고 
    
    이에 해리 벡은 승객들이 노선도를 통해 알고싶은 정보(다음에 무슨역이 있는지)만을 담은 새로운 노선도를 만들었고 현재까지도 이용되고 있다.

해리 벡은 승객들이 알고 싶어하는 정보는 정확하게 표현하되 불필요한 정보는 무시함으로써 이해하기 쉽고 단순한 노선도를 만들었다. (승객에 목적에 부합)

이러한 과정을 추상화라고 한다.

<br><br>

### 추상화를 통한 극복

<br>

추상화 => 현실에서 출발하되 불필요한 부분을 제거하고 본질을 드러내는 과정

추상화를 구성하는 2가지 차원

1. 구체적인 사물들간에 공통점을 취하고 차이점을 버리는 일반화를 통해 단순화
2. 중요한 부분을 강조하고 불필요한 부분은 제거함으로써 단순화

<br><br>

### 객체지향과 추상화

<br>

사람은 본능적으로 공통적인 특성을 기준으로 그룹 묶어 관리함으로써 복잡성을 줄인다.

여기서 `공통적인 특성으로 묶기 위한 그릇을 개념`이라고 한다.

> 따라서 개념은 인식할 수 있는 다양한 사물이나 객체에 적용 가능한 기준, 관념, 아이디어이다.

* 개념을 통해 우리는 그룹으로 분류(Classification)을 할 수 있다.
    * 분류란 특정 객체가 특정 개념에 포함시키거나 시키지 않는 작업이다.
* 나눠진 그룹의 구성원을 인스턴스(Instance)라고 한다.

개념 안에는 심볼, 내연, 외연 3가지로 구성된다.

심볼 => 개념을 지칭하는 이름
내연 => 개념의 특징
외연 => 개념에 속하는 인스턴스

즉, 개념은 객체들의 복잡성을 극복하기 위한 도구이다.

<br><br>

### 타입

<br>

    타입은 개념이다.

따라서 객체는 타입에 따라 분류하고 분류된 타입을 통해 프로그램이 실행된다.

타입을 어떻게 결정짓는가? => `객체의 데이터가 아닌 객체의 행동에 의해서 결정된다.` 즉, 다른 객체외 동일한 행동을 할 수 있을 때 같은 타입이 될 수 있다.

또한 동일한 행동을 하더라도 행동의 처리방식(데이터 내부 표현방식)이 다를 수 있는데 이는 객체의 자율성에 의해 나 자신의 행동에는 내가 결정하기 때문에 동일한 타입이 될 수 있으며 이를 `다형성`이라고 한다.

데이터 내부 표현방식과 무관하게 행동만이 타입을 결정짓는다는 것은 내부 데이터를 외부에 노출시킬 필요가 없다는 것이다. 
따라서 행동만을 노출 시키고 내부 데이터를 감추는 캡술화를 해야한다.

그래서 타입은 동적으로 변하는 내부 데이터 값보다는 정적인 행동에 더 집중 시켜 객체를 묘사할 수 있게 도와주는 추상화라고 할 수 있다.

<br><br>

### 일반화/특수화

<br>

트럼프/트럼프 인간처럼 타입과 타입 사이에서 `일반화/특수화 관계`가 나타날 수 있다.

일반화/특수화는 동시에 나타나며, 기존의 트럼프 타입보다는 움직이거나 말을 할 수 있는 다양한 행동들이 있는 것처럼 더 특수한 경우를 나타내고
다양한 행동들을 가진 트럼프 인간보다는 행동이 적지만 더 포괄적인 행동들이 있는 일반적인 경우를 나타낸다.

위 사례처럼 `일반화/특수화 역시 행동에 의해 결정된다.`

일반화/특수화는 타입간의 관계를 나타내기 때문에 특수화가 된 타입을 `서브 타입`이라 하며 일반화가 된 타입을 `슈퍼 타입`이라고 한다.

또한 앨리스가 트럼프 인간들을 단순히 트럼프의 속성만을 더 부각시켜 트럼프로 일반화 시킨 것처럼 일반화 역시 추상화 도구 중 하나이다.

<br><br>

----

<br><br><br>
    
## 역할, 책임, 협력

<br>

>협력을 결정하면 행동이 결정되고, 행동이 결정되면 상태를 결정한다. 따라서 객체들간에 협력에 집중해야한다.

    참고) 재판장에 도착한 앨리스 이야기

<br><br>

### 협력

<br>

    협력은 연쇄적인 다수의 요청과 응답으로 구성된다.

즉, 재판장 이야기처럼 재판이라는 협력하에 연쇄적으로 요청하고 그에 따라 응답을 한다.

1. 누군가 왕에게 재판을 시작하라고 지시
2. 왕은 토끼에게 증인을 부를 것을 지시
3. 토까는 모자장수에게 입장할 것이라고 지시
4. 모자장수는 입장함으로써 응답.
5. 모자장수가 입장했으므로 토끼는 왕의 요청에 응답
6. 왕은 모자장수에게 증언을 요청
7. 모자장수는 증언을 함으로써 응답

또한 요청에 응답할 수 있는 이유는 요청에 따른 적절한 응답을 할 수 있기 때문이다. => 이러한 요청과 응답이 책임을 정의한다.

<br><br>

### 책임

<br>

    요청에 따른 적절한 행동을 할 수 있는 경우 객체가 책임을 가진다.

책임은 무엇을 알고 있는가와 할 수 있는가로 구성된다.

할 수 있는가

* 객체를 생성하거나 계산을 하는 등의 스스로 하는 것 => 요청에 따른 모자장수가 증언을 시작
* 다른 객체의 행동을 시작시키는 것 => 토끼는 모자장수에게 입장할 것을 요청
* 다른 객체의 활동을 제어하고 조절하는 것 => 왕이 토끼에게 모자장수를 불러오라고 요청

무엇을 알고 있는가

* 개인적인 정보에 대해 아는 것 => 모자장수가 알고았는 바에 대해 증언
* 관련된 객체에 관해 아는 것 => 토끼는 모자장수를 알고 있기 때문에 요청할 수 있다.
* 자신이 유도하거나 계산할 수 있는 것에 관해 아는 것 => 모자장수는 어떤 것에 대해 증언을 할지 알고 있다.

즉, 책임은 외부에 제공할 수 있는 정보와 서비스들이다.

메세지를 통해 요청과 응답을 하여 협력을 할 수 있고 받은 메세지를 통해 책임에 맞는 행동을 한다.

<br><br>

### 역할

<br>

위 예시에서 등장인물마다 각각의 역할과 책임을 가지고 있다.

* 왕 => 재판장
    * 재판 시작 요청에 의해 재판 시작가능
    * 증인을 부르도록 토끼에게 요청 가능
* 여왕 => 재판장
    * 재판 시작 요청에 의해 재판 시작가능
    * 증인을 부르도록 토끼에게 요청 가능
* 모자장수 => 증인
    * 증인석에 입장
    * 증언
* 요리사 => 증인
    * 증인석에 입장
    * 증언
* 앨리스 => 증인
    * 증인석에 입장
    * 증언

증인이라는 역할은 증인석에 입장/증언 2가지의 책임을 수행가능한 것을 의미하며 
모자장수, 요리사, 앨리스는 2가지의 책임을 수행할 수 있기 때문에 같은 역할이 될 수 있다.

즉, 역할은 동일한 책임의 집합을 수행하는 객체들을 추상화한 것이다.

추상화함으로써 재사용성이 가능하고 유연한 객체지향 설계를 이끈다.


<br><br>

### 객체의 모양을 결정하는 협력

<br>

흔한 오류

1. 필요한 데이터를 저장하기 위해 객체가 존재
    * 객체가 존재하는 이유는 행위를 수행하여 협력에 참여하기 위해 존재한다,
2. 객체지향이 클래스와 클래스 간의 관계를 표현하는 시스템의 정적인 측면에 중점을 둔다.
    * 클래스는 단지 구현 메카니즘, 중요한 것은 협력에 참여하는 동적인 객체
3. 실수하는 설계는 각 객체를 독립적으로 본다.
    * 객체가 참여하는 협력에 초점을 맞춰야한다.

올바른 설계

1. 협력을 설계 => 설계에 참여한 객체들의 요청과 응답을 결정 => 결정된 요청과 응답은 수행될 책임이 된다.
2. 책임은 행동이 되고 행동을 결정한 후에 행동에 필요한 데이터를 결정
3. 행동과 데이터가 결정된 후에 클래스의 구현 방법을 결정

<br><br>

----

<br><br><br>
    
## 책임과 메세지

> 쉬운 협력을 위해서는 자율적인 책임을 만들어야하며, 책임을 자율적으로 만들때 외부와 내부를 만드시 구분해야한다.

<br><br>

### 자율적인 책임

<br>

객체지향 공동체의 기본단위는 `자율적인 객체`

자율적인 객체는 요청이 오면 스스로 판단하고 그에 따라 적절한 행동을 수행(책임)할 수 있어야한다.

    적절한 책임은 자율적인 객체를 낳고 자율적인 객체들이 모여 협력을 이룬다.

여기서 적절한 책임은 책임 수행방법을 제안하지 않고, 협력 의도를 표현하지 못할 정도로 추상화 해서는 안된다. => 자율적인 책임은 자율적인 객체들을 만든다.

    따라서 자율적인 책임은 처리방식보다는 무엇을 처리하는지에 대해 초점을 맞춰야한다.


<br><br>

### 메세지와 메서드

<br>

`메세지` => 객체들끼리 소통할 수 있는 유일한 방법

`메세지-전송 메커니즘` => 객체가 다른 객체에게 메세지를 전송하여 그에 맞는 행동을 하게끔 유발하는 것

메세지 전송은 수신자와 메세지 이름, 메세지 인자의 조합이다.

모자장수에게 어제 왕국에서 무슨일이 있었는지 증언하라고 왕이 요청했다. => 모자장수.증언(어제, 왕국)

메세지를 처리할 수 있다 = 책임을 수행 할 수 있다

메세지 vs 메서드 => 메세지는 요청 방식, 메세드는 요청 처리 방식

    다형성

    서로 다른 타입에 속하는 객체들이 동일한 메세지를 수신할 경우 서로 다른 메서드를 이용해 메세지를 처리할 수 있는 메커니즘
    즉, 하나의 메세지에 대해 하나 이상의 메서드 사이의 관계이다.
    
    이를 통해 송신자는 수신자가 누구인지 중요한게 아니라 메세지 자체에 더 집중가능
    동일한 책임을 가진 여러 타입들의 객체들과 협력이 가능 (대체가능성)

    => "다형성은 송신자와 수신자 간의 객체 타입에 대한 결합도를 메시지에 대한 결합도로 낮춤으로써 달성한다."


올바른 객체지향 설계는 어떤 객체가 어떤 메시지를 전송할 수 있는가와 어떤 객체가 어떤 메시지를 이해할 수 있는가를 중심으로 객체 사이의 협력 관계를 구성하는 것이다.

<br><br>

### 객체 인터페이스

<br>    

일반적인 인터페이스 => 사용자가 상호작용을 할 수 있도록 이어주는 방밥

인터페이스의 특징

1. 내부 동작원리를 몰라도 된다.
2. 내부 구조가 변경되어도 정상적으로 동작한다.
3. 대상이 변경되어도 동일한 인터페이스라면 정상적으로 상호작용이 가능하다.

객체의 인터페이스 => 메세지의 모음 ~ 객체가 어떤 메세지를 수신할 수 있는지가 객체가 제공하는 인터페이스를 만든다.

즉, 어떤 메세지를 수신할 수 있는가 = 어떤 책임을 가지는지, 어떤 인터페이스를 가지는지 결정한다.

<br><br>

### 인터페이스와 구현의 분리

<br>    

객체지향적인 사고 방식을 이해하기 위해 알아야할 3가지 원칙

1. 좀 더 추상적인 인터페이스
    * 자율성을 보장해야하기 때문에 구체적인 인터페이스보다는 추상적인 인터페이스여야한다.
2. 최소 인터페이스
    * 외부에 노출될 필요 없는 정보는 최대한 감춘다. (객체 자체보다는 협력에 초점을 맞출 것.)
3. 인터페이스와 구현 간에 차이가 있다는 것을 인식

구현 => 공용 인터페이스(외부에 공개된 인터페이스)가 아닌 모든 것

1. 객체의 상태
2. 객체의 행동(메서드)
    * 메서드 내부 코드 자채는 공용 인터페이스에 포함되지 않는다.

즉, 인터페이스와 구현 간에 차이가 있다는 것을 인식의 뜻은 `객체의 외부(공용 인터페이스)와 내부(구현)를 분리`하라는 뜻이다.

분리를 하는 이유는 소프트웨어가 지속적으로 변한다는 점과 객체를 자율적인 존재로 만들어주기 때문이다.

이를 가능하게 해주는 것이 `캡슐화`이다.

캡슐화 => 객체의 자율성을 위해 외부로부터 구현을 감추는 것

캡슐화는 2가지 관점에서 사용됨.

1. 상태와 행위의 캡슐화
    * 상태와 행위를 묶은 후 행위가 외부로부터 노출되어야하는 것들만 공용 인터페이스를 통해 노출 시킨다.
2. 사적인 비밀의 캡슐화
    * 외부에서 상태나 행위를 조작할 수 없도록 공용 인터페이스 뒤로 감춰 공격과 불필요한 간섭을 피한다.

> 객체의 자율성을 위해서는 객체의 내부와 외부를 분리하라는 것이다.

<br><br>

### 책임의 자율성이 협력의 품질을 결정한다.

<br>  

책임의 자율성이 왜 중요한가? / 좋은 협력이란 어떤 것인가?

=> 객체의 책임이 자율적일수록 협력이 이해하기 쉬워지고 유연하게 변경할 수 있다.

1. 자율적인 책임은 협력을 단순하게 만든다.
    * 자율적인 책임은 의도를 간결하게 나타냄으로써 협력하기 쉽게 만든다.
2. 자율적인 책임은 객체의 외부와 내부를 분리시킨다.
    * 요청하는 객체가 몰라도 사적인 부분이 캡슐화 되기 떄문에 인터페이스와 구현이 분리된다.
3. 책임이 자율적일 경우 책임을 수행하는 내부적인 방법을 변경하더라도 외부에 영향을 미치지 않는다.
    * 자율적인 책임은 외부와 내부가 철저히 분리되어 있기 때문에 내부가 변경되더라도 외부에는 영향을 미치지 않는다.
4. 자율적인 책임은 협력의 대상을 다양하게 선택할 수 있는 유연성을 제공한다.
    * 자율적인 책임은 대상이 변경되어도 책임에 따른 행동을 수행할 수 있기 때문에 유연성을 제공
5. 객체가 수행하는 책임들이 자율적일수록 객체의 역할을 이해하기 쉬워진다.
    * 잘 작성된 자율적인 책임들을 통해 역할을 이해할 수 있다.

<br><br>

----

<br><br><br>
    
## 객체 지도

> 안정적인 도메인 모델을 기반으로 시스템의 기능을 구현하라

<br><br>

### 기능 설계 대 구조 설계

<br>

    좋은 설계는 기능과 구조라는 측면을 조화롭게 이뤄져야함.

`기능은 사용자가 목표를 이루기 위해 소프트웨어를 제공하는 주목적`이기 때문에 중요

구조는 기능보다 더 중요한데 그 이유는 `소프트웨어는 지속적으로 요구사항에 따라 변화`하기 때문이다.

변화는 예측할 수 없기 때문에 빠르게 대응할 수 있어야한다. 따라서 구조를 쉽게 변화할 수 있는 안정을 중심으로 설계해야한다.


>따라서 객체지향 세계를 구축하기 위해서는 사용자에게 제공할 기능과 기능을 담을 안정적인 구조가 필요하다

<br><br>

### 안정적인 재료: 구조

<br>

    "구조는 사용자나 이해관계자들이 도메인에 관해 생각하는 개념과 개념들 간의 관계로 표현한다."

도메인 => 사용자가 프로그램을 사용하는 대상 분야 / 사용자가 프로그램을 통해 해결하고 싶은 영역

모델 => 대상을 추상화 시켜 단순화 한 것

도메인 모델 => 영역 안에 있는 개념, 개념간의 관계, 제약 사항 등을 추상화 시켜 놓은 것 / 멘탈 모델 이다.

도메인 모델의 3가지 관점

* 사용자들이 도메인을 바라보는 관점 => 본질을 바라보는 관점(쉽게 변하지 않은)
* 설계자가 시스템을 바라보는 관점
* 소프트웨어 안에 구현된 코드의 모습

객체지향에서는 이를 모방(객체지향은 실제 세계와 표현적 차이가 존재하기 때문에 모방할 수 없다)이 아닌 은유를 통해서 유사한 형태로 보이게 할 수 있다.

    즉, 객체지향을 통해서 은유해야할 대상은 도메인 모델이다. 
    
    1. 표현적 차이를 줄여 소프트웨어가 이해하고 수정하기 쉽게 만들어줌
    2. 도메인 모델은 구조가 안정적이기 때문에 변화에 쉽게 대응할 수 있다.

    기능을 구현할 때 참고 할 수 있는 훌륭한 지도가 된다.

<br><br>

### 불안정적인 재료: 기능

<br>

실제로 사용자에게 중요한 것은 도메인이 아닌 기능이다. 따라서 기능을 담은 정보가 필요하다. 이를 위해 유스케이스 사용

유스케이스 => 사용자와 시스템간의 상호작용의 흐름을 텍스트로 정리하는 기법 => 사용자들의 목표 중심으로 기능들을 이야기 형식으로 묶을 수 있음

유스케이스의 특성

1. 유스케이스는 사용자와 시스템간의 상호작용을 보여주는 텍스트이다.
    * 이야기 흐름 자체가 중요
2. 유스케이스는 시나리오들의 집합이다.
    * 기능을 쪼개 순차적으로 실행하는 방법 하나하나가 시나리오이며 이러한 시나리오가 모여서 기능을 나타내는 유스케이스가 된다.
3. 유스케이스는 단순한 feature 목록과는 다르다.
    * feature는 단순히 독립적인 기능 목록만을 보여주지만 유스케이스는 이야기로 연관된 feature를 순차적으로 가지고 있다.
4. 유스케이스는 UI를 포함하지 않는다.
    * UI는 자주변경되기 때문에 사용자의 행위에만 초점을 맞춘다.
5. 유스케이스는 내부 설계 정보를 담지 않는다.
    * 유스케이스는 설계기법, 객체지향 기법도 아니다. 즉, 단순히 여러개의 시나리오를 하나의 이야기로 묶어 정리하기 위한 기법이다.

<br><br>

### 재료 합치기: 구조의 통합

<br>

안정적인 구조를 개념화 시킨 도메인 모델과 불안정한 기능을 정리한 유스케이스를 기반으로 책임을 도메인 모델에서 나온 객체들에게 할당한다.

사용자와 시스템 관계 역시 객체지향 패러다임에서는 사용자 객체와 시스템 객체 간에 협력이며, 사용자의 요청에 따라 시스템은 적절한 응답을 제공해줘야한다.

책임-주도 설계 방법

1. 시스템의 기능을 책임으로 바꾼다.
2. 도메인 모델에 있는 개념을 은유하여 적절한 객체를 만든다.
3. 필요한 메시지를 식별하면서 객체들에게 책임을 할당한다.
4. 객체를 구현하기 위해 클래스를 추가하고 속성과 함꼐 메서드를 구현한다.

<br><br>

----

<br><br><br>
    
## 함께 모으기

> 클래스는 개념 관점, 명세 관점, 구현 관점을 모두 수용할 수 있도록 개념, 인터페이스, 구현을 함께 드러내야한다.

개념 관점에서의 설계 => 실제 도메인에 있는 개념과 개념 간의 관계를 표현 / 최대한 실제 도메인과 유사하게 반영 할 것

명세 관점에서의 설계 => 객체의 인터페이스에 초점을 맞추며, 객체가 협력을 위해 "무엇"을 할 수 있는가에 초점을 맞춤.

구현 관점에서의 설계 => 객체들의 책임을 수행하는데 필요한 속성, 메서드를 작성, 객체들이 책임을 위해 "어떻게" 수행하는지에 초점을 맞춤.

    명세 관점과 구현 관점의 구분은 매우 중요, 인터페이스와 구현은 반드시 분리해야한다.

<br><br>

### 커피 전문점 도메인

<br>

![실제 주문 흐름](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F7jZel%2Fbtq9s98AXFZ%2FQkgRkoFM9BKFlEBaWdz6D1%2Fimg.png)

위 그림은 각 객체들을 타입과 관계를 이용하여 추상화한 도메인 모델이다.
객체지향 관점에서 커피 전문점이라는 도메인은 메뉴판, 손님, 바리스타, 커피 객체로 이뤄진 작은 세상이다.

객체지향의 올바른 설계를 하기 위해서는 훌륭한 협력을 먼저 설계해야하며 훌륭한 협력을 위해서는 메시지를 먼저 선정해야한다.
메시지를 선택하면 메시지를 수신할 객체를 선정한다.

    첫번 째 메시지는 "커피를 주문하라"이고 도메인 모델에 따라 수행할만한 객체는 손님 객체이다.
    따라서 손님은 이제 "커피를 주문하라"라는 메시지에 응답할 책임이 있다.

    이후 두 번째로 "메뉴 항목을 찾아라"는 손님 객체에서 수행하기에 부적합 하므로
    외부에 요청을 보내야하며 해당 요청을 처리할만한 적절한 객체는 메뉴판 객체이다. 
    (실제 세계에선 메뉴판은 수동적인 존재이지만 객체지향은 모든 객체가 자율성을 가져야하므로 은유를 통해 의인화 한다.)

    손님은 이제 주문할 메뉴 항목에 대한 정보를 얻었으니 "커피를 제조하라"라는 명령을 요청할 수 있다.
    해당 명령은 바리스타 객체가 수행하기 적절하다.


![실제 주문 흐름](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbVrY2m%2Fbtq9rdDXvAa%2FYpw8uS22Vwmy3VBP3kKTY0%2Fimg.png)

이로써 협력에 필요한 객체의 종류, 책임, 메시지에 대한 대략적인 윤곽이 잡힌다.

<br><br>

### 커피 전문점 도메인 (인터페이스 정리하기)

<br>

![실제 주문 흐름](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F9922524C5D68B92D25)

각 객체들이 처리할 수 있는 메세지들이다.

이를 통해 정적인 타입으로 옮김으로써 구현해야한다.

```java

class Customer {
    public void order(String menuName) {}
}

class MenuItem {}

class Menu {
    public MenuItem findMenu(String menuName) {}
}

class Barista {
    public Coffee makeCoffee(MenuItem item) {

    }
}

class Coffee {
    public Coffee(MenuItem item) {

    }
}

```

협력을 통해 외부에서 식별해야하기 때문에 접근자를 public으로 해준다.

<br><br>

### 커피 전문점 도메인 (구현하기)

<br>

주문하는 과정(order 메서드)에서 메뉴판 객체와 바리스타 객체에 접근을 해야한다.
따라서 order 메서드 매개변수에 각 객체를 추가해준다.

```java

class Customer {
    public void order(String menuName, MenuItem menuItem, Barista barista) {}
}

```

=> 구현 도중에 충분히 인터페이스가 변경될 수 있다. (협력 설계에 시간을 너무 쏟지 말고 구현을 통해서 코드를 점진적으로 수정하자)

```java

class Menu {
    private List<MenuItem> items;   // 구현 도중에 생성됨.

    public Menu(List<MenuItem> items) {
        this.items = items;
    }

    public MenuItem findMenu(String menuName) {
        for(MenuItem each : items) {
            if(each.getName().equals(menuName)){
                return each;
            }
        }

        return null;
    }
}

```

items 역시 구현 도중에 결정되었으며 객체 내부 속성이므로 캡슐화가 되었다.

    실제로 인터페이스를 정리할 때 내부 속성을 고려해서 작성하면 안된다.
    객체가 어떤 책임을 수행할지 결정한 후에 책임을 수행하는데 필요한 속성을 결정해야한다.


![실제 주문 흐름](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F7oMGR%2Fbtq9nDXB2Mr%2Fsk1ts4T7pPhKfR3Lk6UTYK%2Fimg.jpg)

설계가 제대로 안된다면 실제로 코드를 작성하면서 협력의 밑그림을 그려보는 것이 좋다. => 테스트 코드 역시 비슷한 원리

<br><br>

### 코드와 세 가지 관점

<br>

> 코드는 개념, 명세, 구현 관점 모두 수용해야한다.

위 코드 역시 도메인 모델에 나와있는 개념을 기반으로 객체를 구성하여 개념 관점에 충족하고
명세 관점은 클래스의 인터페이스를 바라보며, 위 코드 역시 공용 인터페이스를 먼저 구성했기 때문에 충족한다.
마지막으로 구현 관점도 내부 구현을 바로보며, 실제로 속성과 메서드를 구현함으로써 충족한다. (캡슐화 주의 깊게 처리할 것.)

> 도메인 개념을 참조하는 이유

소프트웨어는 항상 변한다. 우리는 예측을 할 수 없기 때문에 그에 따른 발 빠른 대응을 해야하는데 변하지 않은 본질을 기준으로 설계를 해두면
변화에 대응하기 좋다. 또한 코드의 구조와 의미를 쉽게 유추할 수 있게 해준다.

> 인터페이스와 구현은 반드시 분리하라

